#!/usr/bin/env python3
from settings import *
from oracle import *

##########################################
# Padding Oracle Attack Proof of Concept #
##########################################

# TODO: Initialise the key and IV
key = '0123456789abcdef'
IV='0123456789abcdef' # If IV is not provided, the first block won't be able to be decrypted

def poc(encrypted):
    block_number = len(encrypted)//BYTE_NB
    decrypted = bytes()
    # Go through each block
    for i in range(block_number, 0, -1): # zy: 3,2,1 if block_number = 3
        current_encrypted_block = encrypted[(i-1)*BYTE_NB:(i)*BYTE_NB]
        print("i", i)
        # At the first encrypted block, use the initialization vector if it is known
        if(i == 1):
            previous_encrypted_block = bytearray(IV.encode("ascii"))
            print("previous encrypted block: ", previous_encrypted_block)
        else:
            previous_encrypted_block = encrypted[(i-2)*BYTE_NB:(i-1)*BYTE_NB]
 
        bruteforce_block = previous_encrypted_block
        current_decrypted_block = bytearray(IV.encode("ascii"))
        print("current decrypted block: ", current_decrypted_block)
        padding = 0

        # Go through each byte of the block
        for j in range(BYTE_NB, 0, -1):
            padding += 1

            # Bruteforce byte value
            for value in range(0,256):
                bruteforce_block = bytearray(bruteforce_block)
                bruteforce_block[j-1] = (bruteforce_block[j-1] + 1) % 256
                joined_encrypted_block = bytes(bruteforce_block) + current_encrypted_block 

                # Ask the oracle
                if(oracle(joined_encrypted_block)): # zy: checking the validity of PKCS7 padding of guess
                    current_decrypted_block[-padding] = bruteforce_block[-padding] ^ previous_encrypted_block[-padding] ^ padding 
                    # print("current decrypted block: ", current_decrypted_block)
                    # print("current decrypted block byte: ", current_decrypted_block[-padding])
                    # print("bruteforce block: ", bruteforce_block)
                    # print("bruteforce block byte: ", bruteforce_block[-padding])
                    # print("previous encrypted block: ", previous_encrypted_block)
                    # print("previous encrypted block byte: ", previous_encrypted_block[-padding])
                    
                    # zy: The XOR operation is used here to reverse the effect of the padding, in order to recover the original byte from the modified ciphertext and the previous ciphertext block

                    # Prepare newly found byte values
                    for k in range(1, padding+1):
                        bruteforce_block[-k] = padding+1 ^ current_decrypted_block[-k] ^ previous_encrypted_block[-k]

                    break

        decrypted = bytes(current_decrypted_block) + bytes(decrypted)

    return decrypted[:-decrypted[-1]]  # Padding removal

#### Script ####

usage = """
Usage:
  python3 poracle_exploit.py <message>         decrypts and displays the message
  python3 poracle_exploit.py -o <hex code>     displays oracle answer

Cryptographic parameters can be changed in settings.py
"""

if __name__ == '__main__':
    if len(sys.argv) == 2 : #chiffrement
        if len(sys.argv[1])%16!=0:       # code size security
            print(usage)
        else:
            print("Decrypted message: ", poc(bytes.fromhex(sys.argv[1])).decode("ascii"))
    elif len(sys.argv) == 3 and sys.argv[1] == '-o' : #oracle
        print(oracle(bytes.fromhex(sys.argv[2])))
    else:
        print(usage)